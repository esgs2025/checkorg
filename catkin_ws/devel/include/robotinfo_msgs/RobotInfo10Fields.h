// Generated by gencpp from file robotinfo_msgs/RobotInfo10Fields.msg
// DO NOT EDIT!


#ifndef ROBOTINFO_MSGS_MESSAGE_ROBOTINFO10FIELDS_H
#define ROBOTINFO_MSGS_MESSAGE_ROBOTINFO10FIELDS_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace robotinfo_msgs
{
template <class ContainerAllocator>
struct RobotInfo10Fields_
{
  typedef RobotInfo10Fields_<ContainerAllocator> Type;

  RobotInfo10Fields_()
    : data_field_01()
    , data_field_02()
    , data_field_03()
    , data_field_04()
    , data_field_05()
    , data_field_06()
    , data_field_07()
    , data_field_08()
    , data_field_09()
    , data_field_10()  {
    }
  RobotInfo10Fields_(const ContainerAllocator& _alloc)
    : data_field_01(_alloc)
    , data_field_02(_alloc)
    , data_field_03(_alloc)
    , data_field_04(_alloc)
    , data_field_05(_alloc)
    , data_field_06(_alloc)
    , data_field_07(_alloc)
    , data_field_08(_alloc)
    , data_field_09(_alloc)
    , data_field_10(_alloc)  {
  (void)_alloc;
    }



   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _data_field_01_type;
  _data_field_01_type data_field_01;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _data_field_02_type;
  _data_field_02_type data_field_02;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _data_field_03_type;
  _data_field_03_type data_field_03;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _data_field_04_type;
  _data_field_04_type data_field_04;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _data_field_05_type;
  _data_field_05_type data_field_05;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _data_field_06_type;
  _data_field_06_type data_field_06;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _data_field_07_type;
  _data_field_07_type data_field_07;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _data_field_08_type;
  _data_field_08_type data_field_08;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _data_field_09_type;
  _data_field_09_type data_field_09;

   typedef std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other >  _data_field_10_type;
  _data_field_10_type data_field_10;





  typedef boost::shared_ptr< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> const> ConstPtr;

}; // struct RobotInfo10Fields_

typedef ::robotinfo_msgs::RobotInfo10Fields_<std::allocator<void> > RobotInfo10Fields;

typedef boost::shared_ptr< ::robotinfo_msgs::RobotInfo10Fields > RobotInfo10FieldsPtr;
typedef boost::shared_ptr< ::robotinfo_msgs::RobotInfo10Fields const> RobotInfo10FieldsConstPtr;

// constants requiring out of line definition



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator1> & lhs, const ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator2> & rhs)
{
  return lhs.data_field_01 == rhs.data_field_01 &&
    lhs.data_field_02 == rhs.data_field_02 &&
    lhs.data_field_03 == rhs.data_field_03 &&
    lhs.data_field_04 == rhs.data_field_04 &&
    lhs.data_field_05 == rhs.data_field_05 &&
    lhs.data_field_06 == rhs.data_field_06 &&
    lhs.data_field_07 == rhs.data_field_07 &&
    lhs.data_field_08 == rhs.data_field_08 &&
    lhs.data_field_09 == rhs.data_field_09 &&
    lhs.data_field_10 == rhs.data_field_10;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator1> & lhs, const ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace robotinfo_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> const>
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> >
{
  static const char* value()
  {
    return "8f55192575f4e9f87b843008cac6e331";
  }

  static const char* value(const ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0x8f55192575f4e9f8ULL;
  static const uint64_t static_value2 = 0x7b843008cac6e331ULL;
};

template<class ContainerAllocator>
struct DataType< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> >
{
  static const char* value()
  {
    return "robotinfo_msgs/RobotInfo10Fields";
  }

  static const char* value(const ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> >
{
  static const char* value()
  {
    return "string data_field_01\n"
"string data_field_02\n"
"string data_field_03\n"
"string data_field_04\n"
"string data_field_05\n"
"string data_field_06\n"
"string data_field_07\n"
"string data_field_08\n"
"string data_field_09\n"
"string data_field_10\n"
;
  }

  static const char* value(const ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.data_field_01);
      stream.next(m.data_field_02);
      stream.next(m.data_field_03);
      stream.next(m.data_field_04);
      stream.next(m.data_field_05);
      stream.next(m.data_field_06);
      stream.next(m.data_field_07);
      stream.next(m.data_field_08);
      stream.next(m.data_field_09);
      stream.next(m.data_field_10);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct RobotInfo10Fields_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::robotinfo_msgs::RobotInfo10Fields_<ContainerAllocator>& v)
  {
    s << indent << "data_field_01: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.data_field_01);
    s << indent << "data_field_02: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.data_field_02);
    s << indent << "data_field_03: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.data_field_03);
    s << indent << "data_field_04: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.data_field_04);
    s << indent << "data_field_05: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.data_field_05);
    s << indent << "data_field_06: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.data_field_06);
    s << indent << "data_field_07: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.data_field_07);
    s << indent << "data_field_08: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.data_field_08);
    s << indent << "data_field_09: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.data_field_09);
    s << indent << "data_field_10: ";
    Printer<std::basic_string<char, std::char_traits<char>, typename ContainerAllocator::template rebind<char>::other > >::stream(s, indent + "  ", v.data_field_10);
  }
};

} // namespace message_operations
} // namespace ros

#endif // ROBOTINFO_MSGS_MESSAGE_ROBOTINFO10FIELDS_H
